/**
 * generated by Xtext
 */
package fr.irisa.models.program.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import fr.irisa.models.program.program.Day;
import fr.irisa.models.program.program.Room;
import fr.irisa.models.program.program.Session;
import fr.irisa.models.program.program.Talk;
import fr.irisa.models.program.program.WeekDay;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class ProgramGenerator implements IGenerator {
  private final List<Day> days = new ArrayList<Day>();
  
  private final Map<Day, List<Room>> roomsPerDay = new HashMap<Day, List<Room>>();
  
  private final Map<Day, List<Session>> sessionsPerDay = new HashMap<Day, List<Session>>();
  
  private final Map<Session, Map<Room, List<Talk>>> talksPerRoomPerSession = new HashMap<Session, Map<Room, List<Talk>>>();
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    this.days.clear();
    this.roomsPerDay.clear();
    this.sessionsPerDay.clear();
    this.talksPerRoomPerSession.clear();
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterator<Room> _filter = Iterators.<Room>filter(_allContents, Room.class);
    final List<Room> rooms = IteratorExtensions.<Room>toList(_filter);
    TreeIterator<EObject> _allContents_1 = resource.getAllContents();
    Iterator<Day> _filter_1 = Iterators.<Day>filter(_allContents_1, Day.class);
    List<Day> _list = IteratorExtensions.<Day>toList(_filter_1);
    this.days.addAll(_list);
    final Consumer<Day> _function = (Day d) -> {
      final List<Session> sessions = d.getSessions();
      final Set<Room> roomsOfTheDay = new HashSet<Room>();
      final Consumer<Session> _function_1 = (Session s) -> {
        EList<Talk> _talks = s.getTalks();
        final Function1<Talk, Room> _function_2 = (Talk t) -> {
          return t.getRoom();
        };
        List<Room> _map = ListExtensions.<Talk, Room>map(_talks, _function_2);
        roomsOfTheDay.addAll(_map);
      };
      sessions.forEach(_function_1);
      final Comparator<Room> _function_2 = (Room r1, Room r2) -> {
        int _indexOf = rooms.indexOf(r1);
        int _indexOf_1 = rooms.indexOf(r2);
        return (_indexOf - _indexOf_1);
      };
      List<Room> _sortWith = IterableExtensions.<Room>sortWith(roomsOfTheDay, _function_2);
      final List<Room> result = new ArrayList<Room>(_sortWith);
      this.roomsPerDay.put(d, result);
      this.sessionsPerDay.put(d, sessions);
      final Consumer<Session> _function_3 = (Session s) -> {
        final List<Talk> talks = s.getTalks();
        final Consumer<Talk> _function_4 = (Talk t) -> {
          Map<Room, List<Talk>> talksPerRoom = this.talksPerRoomPerSession.get(s);
          boolean _equals = Objects.equal(talksPerRoom, null);
          if (_equals) {
            HashMap<Room, List<Talk>> _hashMap = new HashMap<Room, List<Talk>>();
            talksPerRoom = _hashMap;
            this.talksPerRoomPerSession.put(s, talksPerRoom);
          }
          Room _room = t.getRoom();
          List<Talk> talksInRoom = talksPerRoom.get(_room);
          boolean _equals_1 = Objects.equal(talksInRoom, null);
          if (_equals_1) {
            ArrayList<Talk> _arrayList = new ArrayList<Talk>();
            talksInRoom = _arrayList;
            Room _room_1 = t.getRoom();
            talksPerRoom.put(_room_1, talksInRoom);
          }
          talksInRoom.add(t);
        };
        talks.forEach(_function_4);
      };
      sessions.forEach(_function_3);
    };
    this.days.forEach(_function);
    String _generate = this.generate();
    String _plus = ("var data = " + _generate);
    fsa.generateFile("data.js", _plus);
  }
  
  public String generate() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("[");
    _builder.newLine();
    {
      boolean _hasElements = false;
      for(final Day d : this.days) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "\t");
        }
        _builder.append("\t");
        _builder.append("{");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("name : \"");
        WeekDay _weekDay = d.getWeekDay();
        _builder.append(_weekDay, "\t\t");
        _builder.append("\",");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("rooms : [");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t\t");
        final List<Room> roomsOfDay = this.roomsPerDay.get(d);
        _builder.newLineIfNotEmpty();
        {
          boolean _hasElements_1 = false;
          for(final Room r : roomsOfDay) {
            if (!_hasElements_1) {
              _hasElements_1 = true;
            } else {
              _builder.appendImmediate(",", "\t\t\t");
            }
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("\"");
            _builder.append(r, "\t\t\t");
            _builder.append("\"");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("],");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("sessions : [");
        _builder.newLine();
        {
          EList<Session> _sessions = d.getSessions();
          for(final Session s : _sessions) {
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("{");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("\t");
            _builder.append("name : \"");
            String _name = s.getName();
            _builder.append(_name, "\t\t\t\t");
            _builder.append("\",");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("\t");
            _builder.append("start : \"");
            String _start = s.getStart();
            _builder.append(_start, "\t\t\t\t");
            _builder.append("\",");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("\t");
            _builder.append("end : \"");
            String _end = s.getEnd();
            _builder.append(_end, "\t\t\t\t");
            _builder.append("\",");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("\t");
            _builder.append("talkGroups : [");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("\t\t");
            final Map<Room, List<Talk>> talksPerRoom = this.talksPerRoomPerSession.get(s);
            _builder.newLineIfNotEmpty();
            {
              boolean _equals = Objects.equal(talksPerRoom, null);
              if (_equals) {
                _builder.append("\t");
                _builder.append("\t\t");
                _builder.append("\t\t");
                _builder.append("[]");
                _builder.newLine();
              } else {
                {
                  boolean _hasElements_2 = false;
                  for(final Room r_1 : roomsOfDay) {
                    if (!_hasElements_2) {
                      _hasElements_2 = true;
                    } else {
                      _builder.appendImmediate(",", "\t\t\t\t\t");
                    }
                    _builder.append("\t");
                    _builder.append("\t\t");
                    _builder.append("\t\t");
                    _builder.append("[");
                    _builder.newLine();
                    _builder.append("\t");
                    _builder.append("\t\t");
                    _builder.append("\t\t");
                    _builder.append("\t");
                    final List<Talk> talksInRoom = talksPerRoom.get(r_1);
                    _builder.newLineIfNotEmpty();
                    {
                      boolean _equals_1 = Objects.equal(talksInRoom, null);
                      if (_equals_1) {
                        _builder.append("\t");
                        _builder.append("\t\t");
                        _builder.append("\t\t");
                        _builder.append("\t");
                        _builder.append("{}");
                        _builder.newLine();
                      } else {
                        {
                          boolean _hasElements_3 = false;
                          for(final Talk t : talksInRoom) {
                            if (!_hasElements_3) {
                              _hasElements_3 = true;
                            } else {
                              _builder.appendImmediate(",", "\t\t\t\t\t\t");
                            }
                            _builder.append("\t");
                            _builder.append("\t\t");
                            _builder.append("\t\t");
                            _builder.append("\t");
                            _builder.append("{");
                            _builder.newLine();
                            _builder.append("\t");
                            _builder.append("\t\t");
                            _builder.append("\t\t");
                            _builder.append("\t");
                            _builder.append("\t");
                            boolean _and = false;
                            EList<String> _speakers = t.getSpeakers();
                            boolean _notEquals = (!Objects.equal(_speakers, null));
                            if (!_notEquals) {
                              _and = false;
                            } else {
                              EList<String> _speakers_1 = t.getSpeakers();
                              boolean _isEmpty = _speakers_1.isEmpty();
                              boolean _not = (!_isEmpty);
                              _and = _not;
                            }
                            final boolean hasSpeakers = _and;
                            _builder.newLineIfNotEmpty();
                            _builder.append("\t");
                            _builder.append("\t\t");
                            _builder.append("\t\t");
                            _builder.append("\t");
                            _builder.append("\t");
                            _builder.append("title: \"");
                            String _tilte = t.getTilte();
                            _builder.append(_tilte, "\t\t\t\t\t\t\t");
                            _builder.append("\"");
                            {
                              if (hasSpeakers) {
                                _builder.append(",");
                              }
                            }
                            _builder.newLineIfNotEmpty();
                            {
                              if (hasSpeakers) {
                                _builder.append("\t");
                                _builder.append("\t\t");
                                _builder.append("\t\t");
                                _builder.append("\t");
                                _builder.append("\t");
                                _builder.append("speakers: ");
                                {
                                  EList<String> _speakers_2 = t.getSpeakers();
                                  boolean _hasElements_4 = false;
                                  for(final String sp : _speakers_2) {
                                    if (!_hasElements_4) {
                                      _hasElements_4 = true;
                                    } else {
                                      _builder.appendImmediate(",", "\t\t\t\t\t\t\t");
                                    }
                                    _builder.append("\"");
                                    _builder.append(sp, "\t\t\t\t\t\t\t");
                                    _builder.append("\"");
                                  }
                                }
                                _builder.newLineIfNotEmpty();
                              }
                            }
                            _builder.append("\t");
                            _builder.append("\t\t");
                            _builder.append("\t\t");
                            _builder.append("\t");
                            _builder.append("}");
                            _builder.newLine();
                          }
                        }
                      }
                    }
                    _builder.append("\t");
                    _builder.append("\t\t");
                    _builder.append("\t\t");
                    _builder.append("]");
                    _builder.newLine();
                  }
                }
              }
            }
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("\t");
            _builder.append("]");
            _builder.newLine();
            _builder.append("\t");
            _builder.append("\t\t");
            _builder.append("}");
            _builder.newLine();
          }
        }
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("]");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("]");
    _builder.newLine();
    return _builder.toString();
  }
}
